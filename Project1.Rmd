---
title: "Project1"
author: "Jeanine Holscher \n and Andy Lopez"
date: "`r Sys.Date()`"
output: html_document
---
```{r setup, include = FALSE}
#### Load necessary packages ####
packages <- c("dplyr", "knitr", "kableExtra", "magrittr", "readr", "geosphere")
install_me <- packages[!(packages %in% installed.packages()[, "Package"])]
if (length(install_me)) install.packages(install_me)

library(dplyr)
library(knitr)
library(kableExtra)
library(magrittr)
library(readr)
library(geosphere)

#### Pull data from files that were obtained with wget
confirmationsURL <- "time_series_covid19_confirmed_global.csv"
confirmations <- read_delim(file=confirmationsURL, delim=",")

deathsURL <- "time_series_covid19_deaths_global.csv"
deaths <- read_delim(file=deathsURL, delim=",")
```

## Background
The World Health Organization has recently employed a new data science initiative, *CSIT-165*, that uses data science to characterize pandemic diseases. 
*CSIT-165* disseminates data driven analyses to global decision makers.

*CSIT-165* is a conglomerate comprised of two fabricated entities: *Global Health Union (GHU)* and *Private Diagnostic Laboratories (PDL)*. 
Your and your partner's role is to play a data scientist from one of these two entities.

## Data
> [2019 Novel Coronavirus COVID-19 (2019-nCoV) Data Repository by John Hopkins CSSE](https://github.com/CSSEGISandData/COVID-19/tree/master/csse_covid_19_data/csse_covid_19_time_series)

Data for 2019 Novel Coronavirus is operated by the John Hopkins University Center for Systems Science and Engineering (JHU CSSE).
Data includes daily time series CSV summary tables, including confirmations, recoveries, and deaths. 
Country/region are countries/regions hat conform to World Health Organization (WHO).
Lat and Long refer to coordinates references for the user. 
Date fields are stored in MM/DD/YYYY format.

## Project Objectives

### Objective 1
```{r ob1}
#### Create variables for highest confirmation and highest deaths on 1/22/20
confOrigin <- confirmations[which.max(confirmations$"1/22/20"),]
deathOrigin <- deaths[which.max(deaths$"1/22/20"),]

#### Display location with both highest confirmations and deaths, if none qualify display a different message
if ((confOrigin$Lat == deathOrigin$Lat) && (confOrigin$Long == deathOrigin$Long)) {
  print(paste("Predicted origin: Location with highest confirmations and deaths on 1/22/20"))
  print(paste("Latitude:", confOrigin$Lat, "| Longitude:", confOrigin$Long))
  print(paste("Country/Region:", confOrigin$"Country/Region", "| Province/State:", confOrigin$"Province/State"))
} else {
  print("There is not a location with both the highest confirmations and deaths.")
}
```

### Objective 2
```{r ob2}
i <- 5
confRecent <- (confirmations)

#### Loops through each column and progressively subsets to keep only those rows which have not had any positive cases yet, and breaks the loop when the next subset would result in no data
for (i in 5:length(confRecent))
{
  columnName <- names(confRecent)[i]

  if(nrow(subset(confRecent, ((confRecent)[i]) == 0)) == 0)
  {
    break
  } else {
    confRecent <- subset(confRecent, ((confRecent)[i]) == 0) 
  }

  i <- i + 1
}
```

### Objective 3
```{r ob3}
confOriginLoc <- c(confOrigin$Long, confOrigin$Lat)
confRecentLoc <- c(confRecent$Long, confRecent$Lat)

distanceMeters <- distm(confOriginLoc, confRecentLoc, distGeo)
distanceMiles <- round(distanceMeters * 0.000621371, 2)

print(paste(confRecent$"Province/State", confRecent$"Country/Region", "is", distanceMiles, "miles away from", confOrigin$"Province/State", confOrigin$"Country/Region"))
```

### Objective 4
```{r ob4}
confRisk <- subset(confirmations, !is.na(Lat))
deathsRisk <- subset(deaths, !is.na(Lat))

confRisk <- subset(confRisk, Lat != 0)
deathsRisk <- subset(deathsRisk, Lat != 0)

latestDate <- names(confRisk)[length(confRisk)]

riskScore <- data.frame("Province/State"=confRisk$"Province/State", "Country/Region"=confRisk$"Country/Region", "Confirmations"=confRisk[latestDate], "Deaths"=deathsRisk[latestDate], "Risk Score"=0)

riskScore[5] <- 100 * (riskScore[4] / riskScore[3])

avgRisk <- colMeans(riskScore[5], na.rm=TRUE)

lowRisk <- subset(riskScore, riskScore[5] == (min(riskScore[5], na.rm=TRUE)))
highRisk <- subset(riskScore, riskScore[5] == (max(riskScore[5], na.rm=TRUE)))

lowestRisk <- subset(lowRisk, lowRisk[3] == (max(lowRisk[3], na.rm=TRUE)))
highestRisk <- subset(highRisk, highRisk[3] == (max(highRisk[3], na.rm=TRUE)))

print(paste("Global Average Risk:", avgRisk))

print(paste("Lowest Risk:",  lowestRisk[1], lowestRisk[2], "| Confirmations:", lowestRisk[3], "| Deaths:", lowestRisk[4], "| Risk:", round(lowestRisk[5], 2)))

print(paste("Highest Risk:", highestRisk[1], highestRisk[2], "| Confirmations:", highestRisk[3], "| Deaths:", highestRisk[4], "| Risk:", round(highestRisk[5], 2)))
```

#### Objective 5
```{r ob5}
#### Make list of unique Countries
countryList <- unique(confRisk[2])

#### Make data frame structure with country list and blank spots for other data
summedData <- data.frame("Country"=countryList, "Confirmations"=0, "Deaths"=0)

#### Create subsets by country and populate Confirmations
i <- 1

for (i in 1:nrow(summedData))
{
  tempSubset <- subset(confRisk, confRisk$"Country/Region" == summedData$Country[i])

  summedData$Confirmations[i] <- sum(tempSubset[latestDate], na.rm=TRUE)

  i <- i + 1
}

#### Create subsets by country and populate Deaths
i <- 1

for (i in 1:nrow(summedData))
{
  tempSubset <- subset(deathsRisk, deathsRisk$"Country/Region" == summedData$Country[i])

  summedData$Deaths[i] <- sum(tempSubset[latestDate], na.rm=TRUE)

  i <- i + 1
}

topConfirmations <- slice_max(summedData, Confirmations, n = 5)
topDeaths <- slice_max(summedData, Deaths, n = 5)

kable(topConfirmations, align="lcc")

kable(topDeaths, align="lcc")
```

### GitHub Link
https://github.com/jholscher1885/CSIT165-Project1




